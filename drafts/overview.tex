\documentclass[11pt,a4paper]{article}
\usepackage{hyperref}

\begin{document}

\title{Remote Code Execution System With Arbitrary Package Installations}
\author{
    Ahmed Wael\thanks{Ahmed Wael Nagy Wanas - 20206008}
    \and Adham Hazem\thanks{Adham Hazem Fahmy Shafei - 20206011}
    \and Omar Brikaa\thanks{Omar Adel Abdel Hamid Ahmed Brikaa - 20206043}
    \and Mostafa Ahmed\thanks{Mostafa Ahmed Mohammed Ahmed - 20206073}
    \and Ali Esmat Ahmed Orfy\thanks{Ali Esmat Ahmed Orfy - 20206123}
}
\date{}
\maketitle
\tableofcontents

\section{What is a code execution system?}
A back-end system that lives in the cloud.
It takes a request containing information about certain code to execute: language, source code, files, etc.
and returns the result after executing the code.

\section{Example use cases for code execution systems in general}
\begin{itemize}
    \item Can be integrated with programming competitions and exercises websites like LeetCode, CodeForces, etc.
          so that users can submit and execute code using only the browser
    \item Can be integrated with interactive coding learning \newline environments,
          where learners follow an interactive tutorial on their browser and execute the code without
          installing anything on their system
    \item Can be integrated with online (and collaborative) IDEs to help developers work together in the cloud
          without needing to install the build tools and compilers on their local systems
    \item Can be integrated with coding assignments auto-graders to execute students' code
\end{itemize}

\section{\label{clients}Who are the clients of a code execution system?}
Whenever we use the word ``client", we are referring to other systems which the code execution system is integrated with.
Clients are typically not humans. Humans are typically the clients to the code execution system's client.

\section{\label{traditional-ces}How some code execution systems work}
\begin{itemize}
    \item The code execution system's developers set it up to support packages Xs
    \item Client sends request to system: ``I want to run source code Y that requires packages Zs"
    \item If Zs are not a subset of Xs
          \begin{itemize}
              \item Error
          \end{itemize}
    \item Else
          \begin{itemize}
              \item Execute the program
          \end{itemize}
\end{itemize}
The nuisance here is that clients need to contact the system's developers to add support for additional packages.

\section{How our code execution system will work}
\begin{itemize}
    \item Client sends request to system: ``I want to make a `workspace' X with packages Ys"
    \item System creates an isolated workspace and installs packages Ys in that workspace
    \item Client sends request to system: ``I want to execute source code Z that requires packages Ws on workspace X"
    \item If Ws are not a subset of Ys (low probability, usually a bug on the client side since, in the normal case,
          the client is the one who requests both the workspace and the program execution)
          \begin{itemize}
              \item Error
          \end{itemize}
    \item Else
          \begin{itemize}
              \item Execute the program
          \end{itemize}
\end{itemize}

\section{\label{workspace}So what is a workspace?}
We use the term ``workspace" to refer to a configurable isolated environment in the code execution system
with configurable packages installed.
Clients can run code in the environment of any workspace.
Hence, workspace creation is what allows the ``arbitrary package installations''

\section{Advantages of allowing arbitrary package installations}
There will be no need to contact the code execution system's developers to add support for packages.
This saves time and gives much flexibility.
Hence, our code execution system becomes more general purpose than the ones discussed in (\ref{traditional-ces}).

\section{Similar systems}
\subsection{Piston, Judge0, Riju}
These\footnote{
    Piston: \url{https://github.com/engineer-man/piston};
    Judge0: \url{https://github.com/judge0/judge0};
    Riju: \url{https://github.com/radian-software/riju}
}
belong to the category of code execution systems discussed in (\ref{traditional-ces}).

\subsection{Repl.it, GitHub Codespaces}
These\footnote{
    Repl.it: \url{https://replit.com/};
    GitHub Codespaces: \url{https://github.com/features/codespaces}
}
are online systems where users can write and execute code using their web browsers.
Users create their own ``repls"/``spaces" with the packages they want.
This is similar to the workspaces concept discussed in (\ref{workspace}).
However, as far as we know, these systems do not provide APIs to execute code.
This makes them almost impossible to integrate with other systems;
the client in these systems is a human\footnote{See (\ref{clients})}.

\section{Challenging parts}
\begin{itemize}
    \item Coming up with the implementation of creating these isolated\newline workspaces
    \item Ensuring each workspace is created in a performant manner
    \item Ensuring code can execute in the context of a workspace in a performant manner
    \item Different security measures like ensuring no intentionally or unintentionally malicious actions can damage a
          workspace's integrity
\end{itemize}

\section{Questions}
\subsection{Is your system a full-stack system for executing code?}
No, unlike full-stack systems, our system is only concerned with the back-end code execution service.
The clients in our system are other systems, not humans.

Our system can be thought of as the building block that is used to
build full systems that make use of remote code execution.
Client systems should be able to self-host their own instances of our system and build upon that.

\subsection{Do you really have a unique selling point to Repl.it?}
Our unique value proposition is that our system is more general-purpose than similar systems (eg. Replit).
Providing an API in addition to some other differences is what allows such generality.
Replit is a full-stack website and hence the clients to such a system are humans;
so for a more precise comparison, we will compare Replit's code execution subsystem with our systems
since in both cases the clients are other systems.

Narrowing down the comparison in this manner makes the first difference in the scopes of both systems obvious:
in the Replit code execution subsystem, the client is the Replit system;
while in our system, the client is any system that uses (by self-hosting) our system.
This is a result of exposing a usable general-purpose api from our system.

The second difference lies in the concept of ``repls" in Replit vs our concept of ``workspaces".
Both repls and workspaces are configurable environments in which code can be executed.
However, code execution in Repls can only use files that are inside of that repl.
So a request to execute code in the repl would be ``run the code you are configured to run."
As a result, the full Replit system was built around the philosophy of:
``share this Replit, the sharee clicks a button, the code runs."
Just like this hello world\footnote{\url{https://replit.com/@Brikaa/HelloWorld}} repl.

Code execution in our workspaces can also do that, and in addition,
they can be provided additional files, scripts, inputs and arguments.
A request to run the code in the workspace would be
``using your environment configuration, run this code with these additional files, these inputs and these arguments."

This difference might sound simple; however, it is a core one.
Let's consider an example in which we have a coding contests website
in which each contest has a certain environment configuration in which the code needs to run.
Let's also pretend that Replit's code execution subsystem provided APIs to manage and execute code in the repls.
If we were using Replit's api, we would have to create a repl that is configured with the target environment
for every contest submission (for every piece of code that we want to validate against the contests test cases).
If we were using our system, we would have to create a workspace that is configured with the target environment
for every contest.
This is because different pieces of code can be run in the same workspace.

In conclusion, using our system, one can create a Replit clone, a leetcode clone, a coding assignment grader
and many more systems that depend on remote code execution.

One might argue that Replit's code execution subsystem might actually be providing such a general-purpose api
and that it is the integration with the full system that makes it specific-purpose.
Even if that is the case, no one is really making use of such api since it isn't usable outside of the Replit system
and such generality would still be our unique selling point.

\subsection{What programming languages do you support?}
Since workspaces allow arbitrary packages to be installed,
then any programming language is supported as long as the client can provide the names of the required packages
for the interpreters/compilers of these languages and the required script to compile/run the code.
This is similar to how Replit has recently supported all languages\footnote{\url{https://blog.replit.com/nix}}.


\end{document}
