- How to handle multiple test cases?
  - If we keep repeating the run stage, a submission can share files between test cases
    - Copy state after compile stage with the same number of test cases

- Why do people want arbitrary package installations?
  - If self-hosted
    - To avoid editing files in order to add support for new languages
      - Is this a good enough reason if you don't have to reload the system to account for new packages?
  - If using an API
    - To get whatever language they want without asking the developers to add support for it

- So we must have options to?
  - Cache packages (for self-hosted and some packages in stuff like the API)
  - Install packages without caching (for stuff like the API API)
    - Though installing packages without caching can't be used for stuff like contests since it will be too slow
      - Is it too slow that it is going to be useless?

- First iteration
  - Experiment with no caching and backend hosting. See the performance
    - Disk and CPU speed bad on vscode codespaces
    - nix-shell -p ghc --run "sleep 0" takes 44 seconds in an openshift docker image build without caching
    - nix-shell -p ghc --run "sleep 0" takes 2.3 seconds in an openshift docker image build with caching
  - Maybe find an alternative to Docker that only does network isolation.
    - We do not need Docker's filesystem isolation, we just need an overlay on top of the nix store
  - Use Judge0-like language ids to determine language
    - Is there a good reason to use names/aliases like in Piston?
      - Don't think so, the main reason it exists in Piston is for the Discord bot. But even that can be worked around
  - TODO
    - Large test cases
    - distributed concerns
      - How do I ensure all instances have the same installed packages at any point in time?
        - How to ensure a node that his been down for some time the required packages that it missed
        - How to ensure a newly added node installs the required packages locally
        - How to ensure running nodes make a package available for use at the same time when they all have it installed
          - Nodes pull the available runtimes from a database
          - A central node is responsible for putting a new runtime in the database when it makes sure all the node installed it
    - Safe internet
      - Have internet connection without being able to communicate between submissions and without being able to communicate with each other and with external devices?
    - Endpoint for deleting packages
      - Need to also delete its remnants

- How can clients test their environments before actually adding it to the system

- Isolate time limit seems to shorten if I run multiple programs under the same box
  - Does it also happen without cg?
    - No
  - Does it also happen with systemd?
    - Yes
  - https://github.com/ioi/isolate/issues/158

- First iteration
  - Endpoint for installing a package
  - Endpoint for running code

- Future iterations
  - Move nix shell when installing instead of re-writing
  - Cache compiled programs using hash
  - Implement bounds on limits
  - Optionally take id for adding runtime and make sure it does not exist
  - Get runtime info endpoint to help in distributed systems consistency
  - CI on packages
    - A repo that includes request templates with CI automated tests run on them to ensure their integrity
      - Users can fork their repository and have their own CI tests
  - Limit overrides
  - Interactive execution
  - Max stdout and stderr size
  - Ensure all boxes and tempdirs are cleaned on startup?
  - API key?
  - Ensure nix shell does not enter an infinite shell hook loop
  - CI/CD
  - Test update nix concurrency
  - How to handle large request bodies in queue?
    - Limit queue size and return "queue full"
    - Websockets and only accept data from client once a queue spot is ready (notifying the client once one is ready)
    - Distributed systems request handler while limiting the number of concurrent tasks on workers
