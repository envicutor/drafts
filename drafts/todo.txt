- Read documents as a new person
- Add sandkasten to inspiration
- Dependencies stage seem to do some common things as the run stage and the compile stage (stdout, stderr, signal, time)
- Get rid of env in Submission object
- Add cache boolean in submission request
- Let user provide shell.nix
- Flow that describes what happens once a worker is started (cleaning up stuck files)
- Submission on disk, lease in memory
- SubmissionsStore -> Database, InMemoryStore

- Are we ready to start modifying the documents?
  - No obvious security exploits
  - No obvious flow gaps
  - No infeasible to implement flow steps

- What do I want?
  - Cache nix shell builds
    - Make use of nix substituters and nix-serve
  - Time to install dependencies shall be constrainable
    - nix-build shell.nix shall run inside nsjail in the builder
      - nsjail command content?
    - nix-build shell.nix shall run inside nsjail in the worker
      - nsjail command content?
  - nix shell builds shall not affect the cache system
    - Run nix-daemon on cache builder
    - Use other users to run the nix-build
      - Channels?
        - Find a way to have shared channels
  - Workers shall access the nix-shell-builds cache
    - nix-build with substituters from env vars (the CacheBuilders as substituters)
  - Executing on workers shall not affect the system
    - Start a Docker container for each submission
    - nsjail nix-build
    - nsjail nix-shell compile.sh
    - nsjail nix-shell run.sh
  - Update submission object in different stages
    - Container init that takes outputs of nix-build, nix-shell compile.sh, nix-shell run.sh and massages them in its
      own output
      - Any way to avoid nix-shell two times?
    - Docker container will have the container init as its init process
    - Worker shall monitor the stdout of the docker container (which will be the stdout of the container init)
      - How to know if the container init fails? Is it useful to know?
        - Exit code of the docker container is the same exit code of the container init so I can easily determine?
      - Parse the message and update the submission object accordingly
  - Ability to not cache
    - boolean cache option. On false, don't enqueue dependencies object

- Questions
  - Dockerfile of builder image?
  - Need for BuilderHealthChecker?
    - Failure to cache will just cause a cache miss
    - Maybe ditch CacheBuilderHealthChecker, BuildStore
      - Store dependencies object in the queue
